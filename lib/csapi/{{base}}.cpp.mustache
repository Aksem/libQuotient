{{>preamble}}
#include "{{filenameBase}}.h"
{{^models}}
#include "converters.h"
{{/models}}{{#operations}}
{{#producesNonJson?}}#include <QtNetwork/QNetworkReply>
{{/producesNonJson?}}#include <QtCore/QStringBuilder>
{{/operations}}
using namespace QMatrixClient;
{{#models.model}}{{#in?}}
QJsonObject QMatrixClient::toJson(const {{qualifiedName}}& pod)
{
    QJsonObject _json{{#propertyMap}} = toJson(pod.{{nameCamelCase}}){{/propertyMap}};{{#vars}}
    addParam<{{^required?}}IfNotEmpty{{/required?}}>(_json, QStringLiteral("{{baseName}}"), pod.{{nameCamelCase}});{{/vars}}
    return _json;
}
{{/in?}}{{#out?}}
{{qualifiedName}} FromJson<{{qualifiedName}}>::operator()(const QJsonValue& jv)
{
    {{^propertyMap}}const auto&{{/propertyMap}}{{#propertyMap}}auto{{/propertyMap}} _json = jv.toObject();
    {{qualifiedName}} result;
    {{#vars}}result.{{nameCamelCase}} =
        fromJson<{{dataType.name}}>(_json.{{#propertyMap}}take{{/propertyMap}}{{^propertyMap}}value{{/propertyMap}}("{{baseName}}"_ls));
    {{/vars}}{{#propertyMap}}
    result.{{nameCamelCase}} = fromJson<{{dataType.name}}>(_json);{{/propertyMap}}
    return result;
}
{{/out?}}{{/models.model}}{{#operations}}
static const auto basePath = QStringLiteral("{{basePathWithoutHost}}");
{{#    operation}}{{#models}}
namespace QMatrixClient
{
    // Converters
{{#model}}{{#in?}}
    QJsonObject toJson(const {{qualifiedName}}& pod)
    {
        QJsonObject _json;{{#vars}}
        addParam<{{^required?}}IfNotEmpty{{/required?}}>(_json, QStringLiteral("{{baseName}}"), pod.{{nameCamelCase}});{{/vars}}
        return _json;
    }
{{/in?}}{{#out?}}
    template <> struct FromJson<{{qualifiedName}}>
    {
        {{qualifiedName}} operator()(const QJsonValue& jv)
        {
            const auto& _json = jv.toObject();
            {{qualifiedName}} result;
{{#vars}}            result.{{nameCamelCase}} =
                fromJson<{{dataType.qualifiedName}}>(_json.value("{{baseName}}"_ls));
{{/vars}}
            return result;
        }
    };
{{/out?}}{{/model}}} // namespace QMatrixClient
{{/    models}}{{#responses}}{{#normalResponse?}}{{#allProperties?}}
class {{camelCaseOperationId}}Job::Private
{
    public:{{#allProperties}}
        {{>maybeOmittableType}} {{paramName}};{{/allProperties}}
};
{{/    allProperties?}}{{/normalResponse?}}{{/responses}}{{#queryParams?}}
BaseJob::Query queryTo{{camelCaseOperationId}}({{#queryParams}}{{>joinedParamDef}}{{/queryParams}})
{
    BaseJob::Query _q;{{#queryParams}}
    addParam<{{^required?}}IfNotEmpty{{/required?}}>(_q, QStringLiteral("{{baseName}}"), {{paramName}});{{/queryParams}}
    return _q;
}
{{/queryParams?}}{{^bodyParams}}
QUrl {{camelCaseOperationId}}Job::makeRequestUrl(QUrl baseUrl{{#allParams?}}, {{#allParams}}{{>joinedParamDef}}{{/allParams}}{{/allParams?}})
{
    return BaseJob::makeRequestUrl(std::move(baseUrl),
            basePath{{#pathParts}} % {{_}}{{/pathParts}}{{#queryParams?}},
            queryTo{{camelCaseOperationId}}({{>passQueryParams}}){{/queryParams?}});
}
{{/    bodyParams}}
static const auto {{camelCaseOperationId}}JobName = QStringLiteral("{{camelCaseOperationId}}Job");

{{camelCaseOperationId}}Job::{{camelCaseOperationId}}Job({{#allParams}}{{>joinedParamDef}}{{/allParams}})
    : BaseJob(HttpVerb::{{#_cap}}{{#_tolower}}{{httpMethod}}{{/_tolower}}{{/_cap}}, {{camelCaseOperationId}}JobName,
        basePath{{#pathParts}} % {{_}}{{/pathParts}}{{#queryParams?}},
        queryTo{{camelCaseOperationId}}({{>passQueryParams}}){{/queryParams?}}{{#skipAuth}}{{#queryParams?}},
        {}{{/queryParams?}}, false{{/skipAuth}}){{#responses}}{{#normalResponse?}}{{#allProperties?}}
    , d(new Private){{/allProperties?}}{{/normalResponse?}}{{/responses}}
{
{{#headerParams?}}{{#headerParams}}    setRequestHeader("{{baseName}}", {{paramName}}.toLatin1());
{{/headerParams}}
{{/headerParams?
}}{{#bodyParams?
}}{{#inlineBody}}    setRequestData(Data({{!
                        }}{{#consumesNonJson?}}{{nameCamelCase}}{{/consumesNonJson?
                        }}{{^consumesNonJson?}}toJson({{nameCamelCase}}){{/consumesNonJson?}}));{{/inlineBody
}}{{^inlineBody}}    QJsonObject _data;{{#bodyParams}}
    addParam<{{^required?}}IfNotEmpty{{/required?}}>(_data, QStringLiteral("{{baseName}}"), {{paramName}});{{/bodyParams}}
    setRequestData(_data);{{/inlineBody}}
{{/bodyParams?}}{{#producesNonJson?}}    setExpectedContentTypes({ {{#produces}}"{{_}}"{{>cjoin}}{{/produces}} });
{{/producesNonJson?}}}{{!<- mind the actual brace}}
{{#    responses}}{{#normalResponse?}}{{#allProperties?}}
{{camelCaseOperationId}}Job::~{{camelCaseOperationId}}Job() = default;
{{#        allProperties}}
{{>qualifiedMaybeCrefType}} {{camelCaseOperationId}}Job::{{paramName}}(){{^moveOnly}} const{{/moveOnly}}
{
    return {{#moveOnly}}std::move({{/moveOnly}}d->{{paramName}}{{#moveOnly}}){{/moveOnly}};
}
{{/        allProperties}}{{#producesNonJson?}}
BaseJob::Status {{camelCaseOperationId}}Job::parseReply(QNetworkReply* reply)
{
    {{#headers}}d->{{paramName}} = reply->rawHeader("{{baseName}}"); {{! We don't check for required headers yet }}
    {{/headers}}{{#properties}}d->{{paramName}} = reply;{{/properties}}
    return Success;
}{{/       producesNonJson?}}{{^producesNonJson?}}
BaseJob::Status {{camelCaseOperationId}}Job::parseJson(const QJsonDocument& data)
{
    auto json = data.object();
    {{#        properties}}{{#required?}}if (!json.contains("{{baseName}}"_ls))
        return { JsonParseError,
            "The key '{{baseName}}' not found in the response" };
    {{/required?}}d->{{paramName}} = fromJson<{{dataType.name}}>(json.value("{{baseName}}"_ls));
    {{/        properties}}return Success;
}{{/       producesNonJson?}}
{{/allProperties?}}{{/normalResponse?}}{{/responses}}{{/operation}}{{/operations}}
